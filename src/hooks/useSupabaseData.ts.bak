import { useEffect, useMemo, useState } from 'react';
import { dbService } from '../lib/supabase';
import { useAuth } from '../contexts/AuthContext';

// --- UUID guard helper (production-safe) ---
const isUuid = (v?: string | null): boolean =>
  !!v && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);

type DashboardData = {
  totalProperties: number;
  totalOwners: number;
  totalTenants: number;
  totalContracts: number;
  activeContracts: number;
  monthlyRevenue: number;
  occupancyRate: number;
};

type UseRealtimeResult<T> = {
  data: T[];
  loading: boolean;
  error: string | null;
  reload: () => Promise<void>;
};

// --- OHADA terms (templates simples & s√ªrs c√¥t√© client) ---
function ohadaManagementTerms(owner: any, agency: any) {
  return [
    'CONTRAT DE MANDAT DE GESTION ‚Äì OHADA',
    `Agence: ${agency?.name ?? 'Votre Agence'} ‚Äì Propri√©taire: ${owner?.first_name ?? ''} ${owner?.last_name ?? ''}`.trim(),
    'Objet: Mandat de gestion locative des biens du Propri√©taire.',
    'Dur√©e: 12 mois renouvelable par tacite reconduction.',
    'R√©mun√©ration: Commission mensuelle de gestion (taux selon devis).',
    'Obligations: Conform√©ment aux actes uniformes OHADA et lois de C√¥te d‚ÄôIvoire.',
    'R√©siliation: Pr√©avis 1 mois, solde des comptes, remise des documents.',
    'Fait √† Abidjan, en deux exemplaires originaux.'
  ].join('\n');
}

function ohadaRentalPrecontract(tenant: any, agency: any) {
  return [
    'PROTOCOLE D‚ÄôADH√âSION LOCATIVE ‚Äì OHADA (Pr√©-contrat)',
    `Agence: ${agency?.name ?? 'Votre Agence'} ‚Äì Locataire: ${tenant?.first_name ?? ''} ${tenant?.last_name ?? ''}`.trim(),
    'Objet: Pr√©figuration d‚Äôun contrat de location √† venir.',
    'Loyer et charges: √Ä d√©finir lors de l‚Äôattribution du logement.',
    'D√©p√¥t de garantie: √Ä d√©finir.',
    'Dur√©e: √Ä d√©finir (pr√©-contrat non exclusif).',
    'Clauses g√©n√©rales conformes au droit OHADA et lois de C√¥te d‚ÄôIvoire.',
    'Fait √† Abidjan, en deux exemplaires.'
  ].join('\n');
}

/**
 * Hook unifi√©: charge les 4 entit√©s + calcule un dashboard simple.
 * - Ne fait rien tant que l'agence n'est pas un UUID valide (√©vite 22P02)
 * - Peut √™tre appel√© sans argument: user lu depuis AuthContext
 */
export function useSupabaseData(overrideUser?: { agencyId?: string | null }) {
  const { user: ctxUser } = useAuth();
  const user = overrideUser ?? ctxUser;

  const [owners, setOwners] = useState<any[]>([]);
  const [properties, setProperties] = useState<any[]>([]);
  const [tenants, setTenants] = useState<any[]>([]);
  const [contracts, setContracts] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const reset = () => {
    setOwners([]); setProperties([]); setTenants([]); setContracts([]);
    setError(null);
  };

  const fetchAll = async () => {
    const agencyId = user?.agencyId ?? null;

    if (!isUuid(agencyId)) {
      console.warn('‚è≠Ô∏è agencyId invalide/absent ‚Äî skip requ√™tes Supabase');
      reset();
      return;
    }

    setLoading(true); setError(null);
    try {
      const [o, p, t, c] = await Promise.all([
        dbService.getOwners(agencyId),
        dbService.getProperties(agencyId),
        dbService.getTenants(agencyId),
        dbService.getContracts(agencyId),
      ]);
      setOwners(o ?? []);
      setProperties(p ?? []);
      setTenants(t ?? []);
      setContracts(c ?? []);
    } catch (e: any) {
      console.error('‚ùå useSupabaseData error:', e);
      setError(e?.message || 'Erreur inconnue');
      reset();
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAll();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.agencyId]);

  const stats: DashboardData = useMemo(() => {
    const totalProps = properties.length;
    const totalOwners = owners.length;
    const totalTenants = tenants.length;
    const totalContracts = contracts.length;
    const activeContracts = contracts.filter((c: any) => c.status === 'active').length;
    const monthlyRevenue = contracts.reduce((sum: number, c: any) => sum + (c?.monthly_rent || 0), 0);
    const occupancyRate = totalProps ? Math.round((properties.filter((p: any) => p.status === 'occupied').length / totalProps) * 100) : 0;

    return {
      totalProperties: totalProps,
      totalOwners,
      totalTenants,
      totalContracts,
      activeContracts,
      monthlyRevenue,
      occupancyRate,
    };
  }, [owners, properties, tenants, contracts]);

  return {
    owners, properties, tenants, contracts,
    stats,
    loading, error,
    reload: fetchAll,
  };
}

/**
 * ‚úÖ Compat: m√™me signature que l'ancien hook
 *   useRealtimeData(fetcher, 'contracts') -> { data, loading, error, reload }
 *   fetcher est typiquement dbService.getContracts (agencyId) => Promise<any[]>
 */
export function useRealtimeData<T = any>(
  fetcher: (agencyId?: string) => Promise<T[]>,
  _key: 'owners' | 'properties' | 'tenants' | 'contracts'
): UseRealtimeResult<T> {
  const { user } = useAuth();
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const load = async () => {
    const agencyId = user?.agencyId ?? null;
    if (!isUuid(agencyId)) {
      console.warn('‚è≠Ô∏è useRealtimeData: agencyId invalide/absent ‚Äî skip');
      setData([]);
      return;
    }
    setLoading(true); setError(null);
    try {
      const rows = await fetcher(agencyId);
      setData(rows ?? []);
    } catch (e: any) {
      console.error('‚ùå useRealtimeData error:', e);
      setError(e?.message || 'Erreur inconnue');
      setData([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { load(); /* eslint-disable-next-line */ }, [user?.agencyId, fetcher]);
  return { data, loading, error, reload: load };
}

/**
 * ‚úÖ Compat: renvoie { stats, loading, error, reload }
 *   pour correspondre √† l'ancien Dashboard.
 */
export function useDashboardStats() {
  const { user } = useAuth();
  const { stats, loading, error, reload } = useSupabaseData(user);
  return { stats, loading, error, reload };
}

/* --- Compatibilit√©: hooks CRUD g√©n√©riques utilis√©s par des listes --- */
type TableKey = 'owners' | 'properties' | 'tenants' | 'contracts';
type CreatorFn = (payload: any) => Promise<any>;

export function useSupabaseCreate() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const create = async (
    tableOrFn: TableKey | CreatorFn,
    payload: any
  ) => {
    setLoading(true); setError(null);
    try {
      const isFn = typeof tableOrFn === 'function';
      let created: any;

      if (isFn) {
        // Compat: ex. create(dbService.createOwner, data)
        created = await (tableOrFn as CreatorFn)(payload);
      } else {
        // Compat: ex. create('owners', data)
        const table = tableOrFn as TableKey;
        switch (table) {
          case 'owners': created = await dbService.createOwner(payload); break;
          case 'properties': created = await dbService.createProperty(payload); break;
          case 'tenants': created = await dbService.createTenant(payload); break;
          case 'contracts': created = await dbService.createContract(payload); break;
          default: throw new Error(`Unsupported table for create: ${tableOrFn as any}`);
        }
      }

      // üîÅ G√©n√©ration automatique de contrats OHADA
      const agencyId = user?.agencyId ?? null;
      if (isUuid(agencyId) && created?.id) {
        try {
          const agency = { id: agencyId, name: 'Votre Agence' };

          // Si propri√©taire cr√©√© ‚Üí contrat de gestion (mandat)
          if ((payload?.firstName || payload?.first_name) && (payload?.lastName || payload?.last_name) && (payload?.phone || payload?.email)) {
            if ((payload?.table === 'owners') || (!isFn && (tableOrFn as TableKey) === 'owners')) {
              const terms = ohadaManagementTerms(
                { first_name: payload.firstName ?? payload.first_name, last_name: payload.lastName ?? payload.last_name },
                agency
              );
              await dbService.createContract({
                agency_id: agencyId,
                owner_id: created.id,
                type: 'gestion',
                status: 'active',
                start_date: new Date().toISOString().split('T')[0],
                terms,
              });
            }
          }

          // Si locataire cr√©√© ‚Üí pr√©contrat de location
          if ((payload?.firstName || payload?.first_name) && (!payload?.owner_id)) {
            if ((payload?.table === 'tenants') || (!isFn && (tableOrFn as TableKey) === 'tenants')) {
              const terms = ohadaRentalPrecontract(
                { first_name: payload.firstName ?? payload.first_name, last_name: payload.lastName ?? payload.last_name },
                agency
              );
              await dbService.createContract({
                agency_id: agencyId,
                tenant_id: created.id,
                type: 'location',
                status: 'draft',
                start_date: new Date().toISOString().split('T')[0],
                terms,
              });
            }
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Auto-g√©n√©ration contrat OHADA: √©chec (non bloquant)', e);
        }
      }

      return created;
    } catch (e: any) {
      setError(e?.message || 'Erreur cr√©ation');
      throw e;
    } finally {
      setLoading(false);
    }
  };

  return { create, loading, error };
}

export function useSupabaseDelete() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const remove = async (
    table: 'owners' | 'properties' | 'tenants' | 'contracts',
    id: string
  ) => {
    setLoading(true); setError(null);
    try {
      switch (table) {
        case 'owners': return await dbService.deleteOwner(id);
        case 'properties': return await dbService.deleteProperty(id);
        case 'tenants': return await dbService.deleteTenant(id);
        case 'contracts': return await dbService.deleteContract(id);
        default: throw new Error(`Unsupported table for delete: ${table}`);
      }
    } catch (e: any) {
      setError(e?.message || 'Erreur suppression');
      throw e;
    } finally {
      setLoading(false);
    }
  };

  // alias pour compat
  const del = remove;
  return { remove, del, loading, error };
}
